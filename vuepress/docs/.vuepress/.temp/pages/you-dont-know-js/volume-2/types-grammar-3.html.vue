<template><div><h1 id="第3章-原生函数" tabindex="-1"><a class="header-anchor" href="#第3章-原生函数" aria-hidden="true">#</a> 第3章：原生函数</h1>
<p>在第1和第2章中，我们多次提到了一些内建函数，通常称为“原生类型”，比如 <code v-pre>String</code> 和 <code v-pre>Number</code>。现在让我们来仔细检视它们。</p>
<p>这是最常用的原生类型的一览：</p>
<ul>
<li><code v-pre>String()</code></li>
<li><code v-pre>Number()</code></li>
<li><code v-pre>Boolean()</code></li>
<li><code v-pre>Array()</code></li>
<li><code v-pre>Object()</code></li>
<li><code v-pre>Function()</code></li>
<li><code v-pre>RegExp()</code></li>
<li><code v-pre>Date()</code></li>
<li><code v-pre>Error()</code></li>
<li><code v-pre>Symbol()</code> —— 在 ES6 中被加入的！</li>
</ul>
<p>如你所见，这些原生类型实际上是内建函数。</p>
<p>熟悉<code v-pre>Java</code>的开发者会发现，JavaScript 的 <code v-pre>String()</code> 看起来像是你曾经用来创建字符串值的 <code v-pre>String(..)</code> 构造器。所以，你很快就会观察到你可以做这样的事情：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Hello World!"</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这些原生类型的每一种确实可以被用作一个原生类型的构造器。但是被构建的东西可能与你想象的不同：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// "object" ... 不是 "String"</span>
a <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object String]"</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建值的构造器形式（<code v-pre>new String(&quot;abc&quot;)</code>）的结果是一个基本类型值（<code v-pre>&quot;abc&quot;</code>）的包装器对象。</p>
<p>重要的是，<code v-pre>typeof</code> 显示这些对象不是它们自己的特殊 <em>类型</em>，而是 <code v-pre>object</code> 类型的子类型。</p>
<p>这个包装器对象可以被进一步观察，像这样：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个语句的输出会根据你使用的浏览器变化，因为对于开发者的查看，开发者控制台可以自由选择它认为合适的方式来序列化对象。</p>
<p><strong>注意：</strong> 在写作本书时，最新版的 Chrome 打印出这样的东西：<code v-pre>String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}</code>。但是老版本的 Chrome 曾经只打印出这些：<code v-pre>String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}</code>。当前最新版的 Firefox 打印 <code v-pre>String [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>，但它曾经以斜体字打印 <code v-pre>&quot;abc&quot;</code>，点击它可以打开对象查看器。当然，这些结果是总频繁变更的，而且你的体验也许不同。</p>
<p>重点是，<code v-pre>new String(&quot;abc&quot;)</code> 为 <code v-pre>&quot;abc&quot;</code> 创建了一个字符串包装器对象，而不仅是基本类型值 <code v-pre>&quot;abc&quot;</code> 本身。</p>
<h2 id="内部-class" tabindex="-1"><a class="header-anchor" href="#内部-class" aria-hidden="true">#</a> 内部 <code v-pre>[[Class]]</code></h2>
<p><code v-pre>typeof</code> 的结果为 <code v-pre>&quot;object&quot;</code> 的值（比如数组）被额外地打上了一个内部的标签属性 <code v-pre>[[Class]]</code>（请把它考虑为一个内部的分类方法，而非与传统的面向对象编码的类有关）。这个属性不能直接地被访问，但通常可以间接地通过在这个值上借用默认的 <code v-pre>Object.prototype.toString(..)</code> 方法调用来展示。举例来说：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object Array]"</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">regex-literal</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object RegExp]"</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，对于这个例子中的数组来说，内部的 <code v-pre>[[Class]]</code> 值是 <code v-pre>&quot;Array&quot;</code>，而对于正则表达式，它是 <code v-pre>&quot;RegExp&quot;</code>。在大多数情况下，这个内部的 <code v-pre>[[Class]]</code> 值对应于关联这个值的内建的原生类型构造器（见下面的讨论），但事实却不总是这样。</p>
<p>基本类型呢？首先，<code v-pre>null</code> 和 <code v-pre>undefined</code>：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object Null]"</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object Undefined]"</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>你会注意到，不存在 <code v-pre>Null()</code> 和 <code v-pre>Undefined()</code> 原生类型构造器，但不管怎样 <code v-pre>&quot;Null&quot;</code> 和 <code v-pre>&quot;Undefined&quot;</code> 是被暴露出来的内部 <code v-pre>[[Class]]</code> 值。</p>
<p>但是对于像 <code v-pre>string</code>、<code v-pre>number</code>、和 <code v-pre>boolean</code> 这样的简单基本类型，实际上会启动另一种行为，通常称为“封箱（boxing）”（见下一节“封箱包装器”）：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object String]"</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object Number]"</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object Boolean]"</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个代码段中，每一个简单基本类型都自动地被它们分别对应的对象包装器封箱，这就是为什么 <code v-pre>&quot;String&quot;</code>、<code v-pre>&quot;Number&quot;</code>、和 <code v-pre>&quot;Boolean&quot;</code> 分别被显示为内部 <code v-pre>[[Class]]</code> 值。</p>
<p><strong>注意：</strong> 从 ES5 发展到 ES6 的过程中，这里展示的 <code v-pre>toString()</code> 和 <code v-pre>[[Class]]</code> 的行为发生了一点儿改变，但我们会在本系列的 <em>ES6 与未来</em> 一书中讲解它们的细节。</p>
<h2 id="封箱包装器" tabindex="-1"><a class="header-anchor" href="#封箱包装器" aria-hidden="true">#</a> 封箱包装器</h2>
<p>这些对象包装器服务于一个非常重要的目的。基本类型值没有属性或方法，所以为了访问 <code v-pre>.length</code> 或 <code v-pre>.toString()</code> 你需要这个值的对象包装器。值得庆幸的是，JS 将会自动地 <em>封箱</em>（也就是包装）基本类型值来满足这样的访问。</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "ABC"</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，如果你想以通常的方式访问这些字符串值上的属性/方法，比如一个 <code v-pre>for</code> 循环的 <code v-pre>i &lt; a.length</code> 条件，这么做看起来很有道理：一开始就得到一个这个值的对象形式，于是 JS 引擎就不需要隐含地为你创建一个。</p>
<p>但事实证明这是一个坏主意。浏览器们长久以来就对 <code v-pre>.length</code> 这样的常见情况进行性能优化，这意味着如果你试着直接使用对象形式（它们没有被优化过）进行“提前优化”，那么实际上你的程序将会 <em>变慢</em>。</p>
<p>一般来说，基本上没有理由直接使用对象形式。让封箱在需要的地方隐含地发生会更好。换句话说，永远也不要做 <code v-pre>new String(&quot;abc&quot;)</code>、<code v-pre>new Number(42)</code> 这样的事情 —— 应当总是偏向于使用基本类型字面量 <code v-pre>&quot;abc&quot;</code> 和 <code v-pre>42</code>。</p>
<h3 id="对象包装器的坑" tabindex="-1"><a class="header-anchor" href="#对象包装器的坑" aria-hidden="true">#</a> 对象包装器的坑</h3>
<p>如果你 <em>确实</em> 选择要直接使用对象包装器，那么有几个坑你应该注意。</p>
<p>举个例子，考虑 <code v-pre>Boolean</code> 包装的值：</p>
<p>🚩：注意</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//a  --> Boolean {false}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Oops"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 永远不会运行</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的问题是，虽然你为值 <code v-pre>false</code> 创建了一个对象包装器，但是对象本身是“truthy”（见第四章），所以使用对象的效果是与使用底层的值 <code v-pre>false</code> 本身相反的，这与通常的期望十分不同。</p>
<p>如果你想手动封箱一个基本类型值，你可以使用 <code v-pre>Object(..)</code> 函数（没有 <code v-pre>new</code> 关键字）：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// "string"</span>
<span class="token keyword">typeof</span> b<span class="token punctuation">;</span> <span class="token comment">// "object"</span>
<span class="token keyword">typeof</span> c<span class="token punctuation">;</span> <span class="token comment">// "object"</span>

b <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object String]"</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "[object String]"</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再说一遍，通常不鼓励直接使用封箱的包装器对象（比如上面的 <code v-pre>b</code> 和 <code v-pre>c</code>），但你可能会遇到一些它们有用的罕见情况。</p>
<h2 id="开箱" tabindex="-1"><a class="header-anchor" href="#开箱" aria-hidden="true">#</a> 开箱</h2>
<p>如果你有一个包装器对象，而你想要取出底层的基本类型值，你可以使用 <code v-pre>valueOf()</code> 方法：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "abc"</span>
b<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
c<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当以一种查询基本类型值的方式使用对象包装器时，开箱也会隐含地发生。这个处理的过程（强制转换）将会在第四章中更详细地讲解，但简单地说：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment">// `b` 拥有开箱后的基本类型值"abc"</span>

<span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// "object"</span>
<span class="token keyword">typeof</span> b<span class="token punctuation">;</span> <span class="token comment">// "string"</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="原生类型作为构造器" tabindex="-1"><a class="header-anchor" href="#原生类型作为构造器" aria-hidden="true">#</a> 原生类型作为构造器</h2>
<p>对于 <code v-pre>array</code>、<code v-pre>object</code>、<code v-pre>function</code> 和正则表达式值来说，使用字面形式来创建它们的值几乎总是更好的选择，而且字面形式与构造器形式所创建的值是同一种对象（也就是，没有非包装的值）。</p>
<p>正如我们刚刚在上面看到的其他原生类型，除非你真的知道你需要这些构造器形式，一般来说应当避免使用它们，这主要是因为它们会带来一些你可能不会想要对付的异常和陷阱。</p>
<h3 id="array" tabindex="-1"><a class="header-anchor" href="#array" aria-hidden="true">#</a> <code v-pre>Array(..)</code></h3>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
b<span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> <code v-pre>Array(..)</code> 构造器不要求在它前面使用 <code v-pre>new</code> 关键字。如果你省略它，它也会像你已经使用了一样动作。所以 <code v-pre>Array(1,2,3)</code> 和 <code v-pre>new Array(1,2,3)</code> 的结果是一样的。</p>
<p><code v-pre>Array</code> 构造器有一种特殊形式，如果它仅仅被传入一个 <code v-pre>number</code> 参数，与将这个值作为数组的 <em>内容</em> 不同，它会被认为是用来“预定数组大小”（嗯，某种意义上）用的长度。</p>
<p>这是个可怕的主意。首先，你会意外地用错这种形式，因为它很容易忘记。</p>
<p>但更重要的是，其实没有预定数组大小这样的东西。你所创建的是一个空数组，并将这个数组的 <code v-pre>length</code> 属性设置为那个指定的数字值。</p>
<p>一个数组在它的值槽上没有明确的值，但是有一个 <code v-pre>length</code> 属性意味着这些值槽是存在的，在 JS 中这是一个诡异的数据结构，它带有一些非常奇怪且令人困惑的行为。可以创建这样的值的能力，完全源自于老旧的、已经废弃的、仅具有历史意义的功能（比如<code v-pre> arguments</code> 这样的“类数组对象”）。</p>
<p><strong>注意：</strong> 带有至少一个“空值槽”的数组经常被称为“稀散数组”。</p>
<p>这是另外一个例子，展示浏览器的开发者控制台在如何表示这样的对象上有所不同，它产生了更多的困惑。</p>
<p>举例来说：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Chrome 中 <code v-pre>a</code> 的序列化表达是（在本书写作时）：<code v-pre>[ undefined x 3 ]</code>。<strong>这真的很不幸。</strong> 它暗示着在这个数组的值槽中有三个 <code v-pre>undefined</code> 值，而事实上这样的值槽是不存在的（所谓的“空值槽（empty slots）” —— 也是一个烂名字！）。</p>
<p>要观察这种不同，试试这段代码：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span>
b<span class="token punctuation">;</span>
c<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> 正如你在这个例子中看到的 <code v-pre>c</code>，数组中的空值槽可以在数组的创建之后发生。将数组的 <code v-pre>length</code> 改变为超过它实际定义的槽值的数目，你就隐含地引入了空值槽。事实上，你甚至可以在上面的代码段中调用 <code v-pre>delete b[1]</code>，而这么做将会在 <code v-pre>b</code> 的中间引入一个空值槽。</p>
<p>对于 <code v-pre>b</code>（在当前的 Chrome 中），你会发现它的序列化表现为 <code v-pre>[ undefined, undefined, undefined ]</code>，与之相对的是 <code v-pre>a</code> 和 <code v-pre>c</code> 的 <code v-pre>[ undefined x 3 ]</code>。糊涂了吧？是的，大家都糊涂了。</p>
<p>更糟糕的是，在写作本书时，Firefox 对 <code v-pre>a</code> 和 <code v-pre>c</code> 报告 <code v-pre>[ , , , ]</code>。你发现为什么这使人犯糊涂了吗？仔细看。三个逗号表示有四个值槽，不是我们期望的三个值槽。</p>
<p><strong>什么！？</strong> Firefox 在它们的序列化表达的末尾放了一个额外的 <code v-pre>,</code>，因为在 ES5 中，列表（数组值，属性列表等等）末尾的逗号是允许的（被砍掉并忽略）。所以如果你在你的程序或控制台中敲入 <code v-pre>[ , , , ]</code> 值，你实际上得到的是一个底层为 <code v-pre>[ , , ]</code> 的值（也就是，一个带有三个空值槽的数组）。这种选择，虽然在阅读开发者控制台时使人困惑，但是因为它使拷贝粘贴的时候准确，所以被留了下来。</p>
<p>如果你现在在摇头或翻白眼儿，你并不孤单！（耸肩）</p>
<p>不幸的是，事情越来越糟。比在控制台的输出产生的困惑更糟的是，上面代码段中的 <code v-pre>a</code> 和 <code v-pre>b</code> 实际上在有些情况下相同，<strong>但在另一些情况下不同</strong>：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "--"</span>
b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "--"</span>

a<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ undefined x 3 ]</span>
b<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ 0, 1, 2 ]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>呃。</strong></p>
<p><code v-pre>a.map(..)</code> 调用会 <em>失败</em> 是因为值槽根本就不实际存在，所以 <code v-pre>map(..)</code> 没有东西可以迭代。<code v-pre>join(..)</code> 的工作方式不同，基本上我们可以认为它是像这样被实现的：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fakeJoin</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> connector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      str <span class="token operator">+=</span> connector<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      str <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fakeJoin</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "--"</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，<code v-pre>join(..)</code> 好用仅仅是因为它 <em>认为</em> 值槽存在，并循环至 <code v-pre>length</code> 值。不管 <code v-pre>map(..)</code> 内部是在做什么，它（显然）没有做出这样的假设，所以源自于奇怪的“空值槽”数组的结果出人意料，而且好像是失败了。</p>
<p>那么，如果你想要 <em>确实</em> 创建一个实际的 <code v-pre>undefined</code> 值的数组（不只是“空值槽”），你如何才能做到呢（除了手动以外）？</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// [ undefined, undefined, undefined ]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>糊涂了吧？是的。这里是它大概的工作方式。</p>
<p><code v-pre>apply(..)</code> 是一个对所有函数可用的工具方法，它以一种特殊方式调用这个使用它的函数。</p>
<p>第一个参数是一个 <code v-pre>this</code> 对象绑定（在本系列的 <em>this 与对象原型</em> 中有详细讲解），在这里我们不关心它，所以我们将它设置为 <code v-pre>null</code>。第二个参数应该是一个数组（或 <em>像</em> 数组的东西 —— 也就是“类数组对象”）。这个“数组”的内容作为这个函数的参数“扩散”开来。</p>
<p>所以，<code v-pre>Array.apply(..)</code> 在调用 <code v-pre>Array(..)</code> 函数，并将一个值（<code v-pre>{ length: 3 }</code> 对象值）作为它的参数值扩散开。</p>
<p>在 <code v-pre>apply(..)</code> 内部，我们可以预见这里有另一个 <code v-pre>for</code> 循环（有些像上面的 <code v-pre>join(..)</code>），它从 <code v-pre>0</code> 开始上升但不包含至 <code v-pre>length</code>（这个例子中是 <code v-pre>3</code>）。</p>
<p>对于每一个索引，它从对象中取得相应的键。所以如果这个数组对象参数在 <code v-pre>apply(..)</code> 内部被命名为 <code v-pre>arr</code>，那么这种属性访问实质上是<code v-pre>arr[0]</code>、<code v-pre>arr[1]</code> 和 <code v-pre>arr[2]</code>。当然，没有一个属性是在 <code v-pre>{ length: 3 }</code> 对象值上存在的，所以这三个属性访问都将返回值 <code v-pre>undefined</code>。</p>
<p>换句话说，调用 <code v-pre>Array(..)</code> 的结局基本上是这样：<code v-pre>Array(undefined,undefined,undefined)</code>，这就是我们如何得到一个填满 <code v-pre>undefined</code> 值的数组的，而非仅仅是一些（疯狂的）空值槽。</p>
<p>虽然对于创建一个填满 <code v-pre>undefined</code> 值的数组来说，<code v-pre>Array.apply( null, { length: 3 } )</code> 是一个奇怪而且繁冗的方法，但是它要比使用砸自己的脚似的 <code v-pre>Array(3)</code> 空值槽要可靠和好得 <strong>太多了</strong>。</p>
<p>底线：你 <strong>在任何情况下，永远不</strong>，也不应该有意地创建并使用诡异的空值槽数组。就别这么干。它们是怪胎。</p>
<h3 id="object-、function-和-regexp" tabindex="-1"><a class="header-anchor" href="#object-、function-和-regexp" aria-hidden="true">#</a> <code v-pre>Object(..)</code>、<code v-pre>Function(..)</code> 和 <code v-pre>RegExp(..)</code></h3>
<p><code v-pre>Object(..)</code>/<code v-pre>Function(..)</code>/<code v-pre>RegExp(..)</code> 构造器一般来说也是可选的（因此除非是特别的目的，应当避免使用）：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">"bar"</span><span class="token punctuation">;</span>
c<span class="token punctuation">;</span> <span class="token comment">// { foo: "bar" }</span>

<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">"bar"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
d<span class="token punctuation">;</span> <span class="token comment">// { foo: "bar" }</span>

<span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"return a * 2;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">"^a*b+"</span><span class="token punctuation">,</span> <span class="token string">"g"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^a*b+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>几乎没有理由使用 <code v-pre>new Object()</code> 构造器形式，尤其因为它强迫你一个一个地添加属性，而不是像对象的字面形式那样一次添加许多。</p>
<p><code v-pre>Function</code> 构造器仅在最最罕见的情况下有用，也就是你需要动态地定义一个函数的参数和/或它的函数体。<strong>不要将 <code v-pre>Function(..)</code> 仅仅作为另一种形式的 <code v-pre>eval(..)</code></strong>。你几乎永远不会需要用这种方式动态定义一个函数。</p>
<p>用字面量形式（<code v-pre>/^a*b+/g</code>）定义正则表达式是被大力采用的，不仅因为语法简单，而且还有性能的原因 —— JS 引擎会在代码执行前预编译并缓存它们。和我们迄今看到的其他构造器形式不同，<code v-pre>RegExp(..)</code> 有一些合理的用途：用来动态定义一个正则表达式的范例。</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"Kyle"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> namePattern <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">"\\b(?:"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">")+\\b"</span><span class="token punctuation">,</span> <span class="token string">"ig"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> matches <span class="token operator">=</span> someText<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>namePattern<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的场景在 JS 程序中一次又一次地合法出现，所以你有需要使用 <code v-pre>new RegExp(&quot;pattern&quot;,&quot;flags&quot;)</code> 形式。</p>
<h3 id="date-和-error" tabindex="-1"><a class="header-anchor" href="#date-和-error" aria-hidden="true">#</a> <code v-pre>Date(..)</code> 和 <code v-pre>Error(..)</code></h3>
<p><code v-pre>Date(..)</code> 和 <code v-pre>Error(..)</code> 原生类型构造器要比其他种类的原生类型有用得多，因为它们没有字面量形式。</p>
<p>要创建一个日期对象值，你必须使用 <code v-pre>new Date()</code>。<code v-pre>Date(..)</code> 构造器接收可选参数值来指定要使用的日期/时间，但是如果省略的话，就会使用当前的日期/时间。</p>
<p>目前你构建一个日期对象的最常见的理由是要得到当前的时间戳（一个有符号整数，从 1970 年 1 月 1 日开始算起的毫秒数）。你可以在一个日期对象实例上调用 <code v-pre>getTime（)</code> 得到它。</p>
<p>但是在 ES5 中，一个更简单的方法是调用定义为 <code v-pre>Date.now()</code> 的静态帮助函数。而且在前 ES5 中填补它很容易：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Date<span class="token punctuation">.</span>now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Date<span class="token punctuation">.</span><span class="token function-variable function">now</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> 如果你不带 <code v-pre>new</code> 调用 <code v-pre>Date()</code>，你将会得到一个那个时刻的日期/时间的字符串表达。在语言规范中没有规定这个表达的确切形式，虽然各个浏览器趋向于赞同使用这样的东西：<code v-pre>&quot;Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)&quot;</code>。</p>
<p><code v-pre>Error(..)</code> 构造器（很像上面的 <code v-pre>Array()</code>）在有 <code v-pre>new</code> 与没有 <code v-pre>new</code> 时的行为是相同的。</p>
<p>你想要创建 error 对象的主要原因是，它会将当前的执行栈上下文捕捉进对象中（在大多数 JS 引擎中，在创建后使用只读的 <code v-pre>.stack</code> 属性表示）。这个栈上下文包含函数调用栈和 error 对象被创建时的行号，这使调试这个错误更简单。</p>
<p>典型地，你将与 <code v-pre>throw</code> 操作符一起使用这样的 error 对象：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"x wasn't provided"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ..</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Error 对象实例一般拥有至少一个 <code v-pre>message</code> 属性，有时还有其他属性（你应当将它们作为只读的），比如 <code v-pre>type</code>。然而，与其检视上面提到的 <code v-pre>stack</code> 属性，最好是在 error 对象上调用 <code v-pre>toString()</code>（明确地调用，或者是通过强制转换隐含地调用 —— 见第四章）来得到一个格式友好的错误消息。</p>
<p><strong>提示：</strong> 技术上讲，除了一般的 <code v-pre>Error(..)</code> 原生类型以外，还有几种特定错误的原生类型：<code v-pre>EvalError(..)</code>、<code v-pre>RangeError(..)</code>、<code v-pre>ReferenceError(..)</code>、<code v-pre>SyntaxError(..)</code>、<code v-pre>TypeError(..)</code> 和 <code v-pre>URIError(..)</code>。但是手动使用这些特定错误原生类型十分少见。如果你的程序确实遭受了一个真实的异常，它们是会自动地被使用的（比如引用一个未声明的变量而得到一个 <code v-pre>ReferenceError</code> 错误）。</p>
<h3 id="symbol" tabindex="-1"><a class="header-anchor" href="#symbol" aria-hidden="true">#</a> <code v-pre>Symbol(..)</code></h3>
<p>在 ES6 中，新增了一个基本值类型，称为“Symbol”。Symbol 是一种特殊的“独一无二”（不是严格保证的!）的值，可以作为对象上的属性使用而几乎不必担心任何冲突。它们主要是为特殊的 ES6 结构的内建行为设计的，但你也可以定义你自己的 symbol。</p>
<p>Symbol 可以用做属性名，但是你不能从你的程序中看到或访问一个 symbol 的实际值，从开发者控制台也不行。例如，如果你在开发者控制台中对一个 Symbol 求值，将会显示 <code v-pre>Symbol(Symbol.create)</code> 之类的东西。</p>
<p>在 ES6 中有几种预定义的 Symbol，做为 <code v-pre>Symbol</code> 函数对象的静态属性访问，比如 <code v-pre>Symbol.create</code>，<code v-pre>Symbol.iterator</code> 等等。要使用它们，可以这样做：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>obj<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*..*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要定义你自己的 Symbol，使用 <code v-pre>Symbol(..)</code> 原生类型。<code v-pre>Symbol(..)</code> 原生类型“构造器”很独特，因为它不允许你将 <code v-pre>new</code> 与它一起使用，这么做会抛出一个错误。</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> mysym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"my own symbol"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mysym<span class="token punctuation">;</span> <span class="token comment">// Symbol(my own symbol)</span>
mysym<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Symbol(my own symbol)"</span>
<span class="token keyword">typeof</span> mysym<span class="token punctuation">;</span> <span class="token comment">// "symbol"</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span>mysym<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"foobar"</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [ Symbol(my own symbol) ]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然 Symbol 实际上不是私有的（在对象上使用 <code v-pre>Object.getOwnPropertySymbols(..)</code> 反射，揭示了 Symbol 其实是相当公开的），但是它们的主要用途可能是私有属性，或者类似的特殊属性。对于大多数开发者，他们也许会在属性名上加入 <code v-pre>_</code> 下划线前缀，这在经常在惯例上表示：“这是一个私有的/特殊的/内部的属性，别碰！”</p>
<p><strong>注意：</strong> <code v-pre>Symbol</code> <em>不是</em> <code v-pre>object</code>，它们是简单的基本标量。</p>
<h3 id="原生类型原型" tabindex="-1"><a class="header-anchor" href="#原生类型原型" aria-hidden="true">#</a> 原生类型原型</h3>
<p>每一个内建的原生构造器都拥有它自己的 <code v-pre>.prototype</code> 对象 —— <code v-pre>Array.prototype</code>，<code v-pre>String.prototype</code> 等等。</p>
<p>对于它们特定的对象子类型，这些对象含有独特的行为。</p>
<p>例如，所有的字符串对象，和 <code v-pre>string</code> 基本值的扩展（通过封箱），都可以访问在 <code v-pre>String.prototype</code> 对象上做为方法定义的默认行为。</p>
<p><strong>注意：</strong> 做为文档惯例，<code v-pre>String.prototype.XYZ</code> 会被缩写为 <code v-pre>String#XYZ</code>，对于其它所有 <code v-pre>.prototype</code> 的属性都是如此。</p>
<ul>
<li><code v-pre>String#indexOf(..)</code>：在一个字符串中找出一个子串的位置</li>
<li><code v-pre>String#charAt(..)</code>：访问一个字符串中某个位置的字符</li>
<li><code v-pre>String#substr(..)</code>、<code v-pre>String#substring(..)</code> 和 <code v-pre>String#slice(..)</code>：将字符串的一部分抽取为一个新字符串</li>
<li><code v-pre>String#toUpperCase()</code> 和 <code v-pre>String#toLowerCase()</code>：创建一个转换为大写或小写的新字符串</li>
<li><code v-pre>String#trim()</code>：创建一个截去开头或结尾空格的新字符串。</li>
</ul>
<p>这些方法中没有一个是在 <em>原地</em> 修改字符串的。修改（比如大小写变换或去空格）会根据当前的值来创建一个新的值。</p>
<p>有赖于原型委托（见本系列的 <em>this 与对象原型</em>），任何字符串值都可以访问这些方法：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">" abc "</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// " ABC "</span>
a<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "abc"</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他构造器的原型包含适用于它们类型的行为，比如 <code v-pre>Number#toFixed(..)</code>（将一个数字转换为一个固定小数位的字符串）和 <code v-pre>Array#concat(..)</code>（混合数组）。所有这些函数都可以访问 <code v-pre>apply(..)</code>、<code v-pre>call(..)</code> 和 <code v-pre>bind(..)</code>，因为 <code v-pre>Function.prototype</code> 定义了它们。</p>
<p>但是，一些原生类型的原型不 <em>仅仅</em> 是单纯的对象：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// "function"</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">prototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 它是一个空函数！</span>

<span class="token class-name">RegExp</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "/(?:)/" —— 空的正则表达式</span>
<span class="token string">"abc"</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token class-name">RegExp</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [""]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个特别差劲儿的主意是，你甚至可以修改这些原生类型的原型（不仅仅是你可能熟悉的添加属性）：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>

<span class="token comment">// 别这么留着它，要不就等着怪事发生吧！</span>
<span class="token comment">// 将`Array.prototype`重置为空</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，<code v-pre>Function.prototype</code> 是一个函数，<code v-pre>RegExp.prototype</code> 是一个正则表达式，而 <code v-pre>Array.prototype</code> 是一个数组。有趣吧？酷吧？</p>
<h4 id="原型作为默认值" tabindex="-1"><a class="header-anchor" href="#原型作为默认值" aria-hidden="true">#</a> 原型作为默认值</h4>
<p><code v-pre>Function.prototype</code> 是一个空函数，<code v-pre>RegExp.prototype</code> 是一个“空”正则表达式（也就是不匹配任何东西），而 <code v-pre>Array.prototype</code> 是一个空数组，这使它们成了可以赋值给变量的，很好的“默认”值 —— 如果这些类型的变量还没有值。</p>
<p>例如：</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isThisCool</span><span class="token punctuation">(</span><span class="token parameter">vals<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> rx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vals <span class="token operator">=</span> vals <span class="token operator">||</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  fn <span class="token operator">=</span> fn <span class="token operator">||</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  rx <span class="token operator">=</span> rx <span class="token operator">||</span> <span class="token class-name">RegExp</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>

  <span class="token keyword">return</span> rx<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>vals<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">isThisCool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token function">isThisCool</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">D</span><span class="token regex-delimiter">/</span></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> 在 ES6 中，我们不再需要使用 <code v-pre>vals = vals || ..</code> 这样的默认值语法技巧了（见第四章），因为在函数声明中可以通过原生语法为参数设定默认值（见第五章）。</p>
<p>这个方式的一个微小的副作用是，<code v-pre>.prototype</code> 已经被创建了，而且是内建的，因此它仅被创建 <em>一次</em>。相比之下，使用 <code v-pre>[]</code>、<code v-pre>function(){}</code> 和 <code v-pre>/(?:)/</code> 这些值本身作为默认值，将会（很可能，要看引擎如何实现）在每次调用 <code v-pre>isThisCool(..)</code> 时重新创建这些值（而且稍可能要回收它们）。这可能会消耗内存/CPU。</p>
<p>另外，要非常小心不要对 <strong>后续要被修改的值</strong> 使用 <code v-pre>Array.prototype</code> 做为默认值。在这个例子中，<code v-pre>vals</code> 是只读的，但如果你要在原地对 <code v-pre>vals</code> 进行修改，那你实际上修改的是 <code v-pre>Array.prototype</code> 本身，这将把你引到刚才提到的坑里！</p>
<p><strong>注意：</strong> 虽然我们指出了这些原生类型的原型和一些用处，但是依赖它们的时候要小心，更要小心以任何形式修改它们。更多的讨论见附录 A“原生原型”。</p>
<h2 id="复习" tabindex="-1"><a class="header-anchor" href="#复习" aria-hidden="true">#</a> 复习</h2>
<p>JavaScript 为基本类型提供了对象包装器，被称为原生类型（<code v-pre>String</code>、<code v-pre>Number</code>、<code v-pre>Boolean</code> 等等）。这些对象包装器使这些值可以访问每种对象子类型的恰当行为（<code v-pre>String#trim()</code> 和 <code v-pre>Array#concat(..)</code>）。</p>
<p>如果你有一个像 <code v-pre>&quot;abc&quot;</code> 这样的简单基本类型标量，而且你想要访问它的 <code v-pre>length</code> 属性或某些 <code v-pre>String.prototype</code> 方法，JS 会自动地“封箱”这个值（用它所对应种类的对象包装器把它包起来），以满足这样的属性/方法访问。</p>
</div></template>


