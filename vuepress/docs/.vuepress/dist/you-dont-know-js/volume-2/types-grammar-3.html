<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.51">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>第3章 原生函数 | </title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.c62ce33e.js"><link rel="modulepreload" href="/assets/types-grammar-3.html.53926110.js"><link rel="modulepreload" href="/assets/types-grammar-3.html.d901835c.js"><link rel="prefetch" href="/assets/1.1.hello-world.html.c9c3a5a1.js"><link rel="prefetch" href="/assets/1.10.if.html.9e1b96da.js"><link rel="prefetch" href="/assets/1.11.includes.html.f730fd82.js"><link rel="prefetch" href="/assets/1.12.parameters.html.cea6009c.js"><link rel="prefetch" href="/assets/1.13.push.html.b4a2eefb.js"><link rel="prefetch" href="/assets/1.14.unshift.html.899e4793.js"><link rel="prefetch" href="/assets/1.2.Pick.html.00955fc1.js"><link rel="prefetch" href="/assets/1.3.Awaited.html.c28eb4dc.js"><link rel="prefetch" href="/assets/1.4.Readonly.html.5504219f.js"><link rel="prefetch" href="/assets/1.5.Tuple-to-object.html.e5ff4876.js"><link rel="prefetch" href="/assets/1.6.First-of-array.html.8963da96.js"><link rel="prefetch" href="/assets/1.7.Length-of-Tuple.html.b566373d.js"><link rel="prefetch" href="/assets/1.8.concat.html.e48cdb0f.js"><link rel="prefetch" href="/assets/1.9.exclude.html.a9065b1a.js"><link rel="prefetch" href="/assets/2.1.Get-Return-Type.html.fc63429d.js"><link rel="prefetch" href="/assets/2.2.omit.html.12f10b17.js"><link rel="prefetch" href="/assets/2.3.Readonly2.html.e66ac73b.js"><link rel="prefetch" href="/assets/2.4.Deep-Readonly.html.a658e6e6.js"><link rel="prefetch" href="/assets/2.5.turn-to-union.html.073cd259.js"><link rel="prefetch" href="/assets/3.1.Simple-Vue.html.99882d01.js"><link rel="prefetch" href="/assets/donate.html.acbabecd.js"><link rel="prefetch" href="/assets/Routine1_pattern-matching-for-extraction.html.875abc65.js"><link rel="prefetch" href="/assets/basic-1.html.9eb41d9a.js"><link rel="prefetch" href="/assets/basic-2.html.f7caa9d2.js"><link rel="prefetch" href="/assets/basic-3.html.34aee1eb.js"><link rel="prefetch" href="/assets/http-2.html.787a8a96.js"><link rel="prefetch" href="/assets/http-3.html.34a30fe1.js"><link rel="prefetch" href="/assets/http-interview.html.ace5bf96.js"><link rel="prefetch" href="/assets/http-optimize.html.69d45db9.js"><link rel="prefetch" href="/assets/http-rpc.html.8491156f.js"><link rel="prefetch" href="/assets/http-websocket.html.7d4a1447.js"><link rel="prefetch" href="/assets/https-ecdhe.html.05368a85.js"><link rel="prefetch" href="/assets/https-optimize.html.6a75aeb7.js"><link rel="prefetch" href="/assets/https-rsa.html.f131cf25.js"><link rel="prefetch" href="/assets/ip-base.html.e6127d4e.js"><link rel="prefetch" href="/assets/ip-ping.html.6302a945.js"><link rel="prefetch" href="/assets/ip-ping_io.html.6c34496f.js"><link rel="prefetch" href="/assets/tcp-challenge-ack.html.3a5fc045.js"><link rel="prefetch" href="/assets/tcp-dump.html.b56080fb.js"><link rel="prefetch" href="/assets/tcp-feature.html.a3d828ae.js"><link rel="prefetch" href="/assets/tcp-interview.html.62d97690.js"><link rel="prefetch" href="/assets/tcp-isn-deff.html.82d20436.js"><link rel="prefetch" href="/assets/tcp-optimize.html.ca87f13b.js"><link rel="prefetch" href="/assets/tcp-out-of-order-fin.html.151c009d.js"><link rel="prefetch" href="/assets/tcp-queue.html.74d5129c.js"><link rel="prefetch" href="/assets/tcp-stream.html.e93bfa43.js"><link rel="prefetch" href="/assets/tcp-syn.html.d732a2c4.js"><link rel="prefetch" href="/assets/Advanced-1.html.fa0fc3db.js"><link rel="prefetch" href="/assets/Advanced-2.html.768f0222.js"><link rel="prefetch" href="/assets/Advanced-3.html.80ef5874.js"><link rel="prefetch" href="/assets/Advanced-4.html.9ac82786.js"><link rel="prefetch" href="/assets/Advanced-5.html.7086659b.js"><link rel="prefetch" href="/assets/base-1.html.a1a4a8f1.js"><link rel="prefetch" href="/assets/base-10.html.5a196727.js"><link rel="prefetch" href="/assets/base-11.html.aab11d1b.js"><link rel="prefetch" href="/assets/base-12.html.e5e162d6.js"><link rel="prefetch" href="/assets/base-13.html.e7f1ec06.js"><link rel="prefetch" href="/assets/base-14.html.7817c35c.js"><link rel="prefetch" href="/assets/base-15.html.234b3135.js"><link rel="prefetch" href="/assets/base-16.html.d8b75899.js"><link rel="prefetch" href="/assets/base-17.html.563cf78a.js"><link rel="prefetch" href="/assets/base-2.html.a766b26b.js"><link rel="prefetch" href="/assets/base-3.html.456ded6f.js"><link rel="prefetch" href="/assets/base-4.html.ad7f3656.js"><link rel="prefetch" href="/assets/base-5.html.d39095e5.js"><link rel="prefetch" href="/assets/base-6.html.b84ee494.js"><link rel="prefetch" href="/assets/base-7.html.178e9a4d.js"><link rel="prefetch" href="/assets/base-8.html.c0808088.js"><link rel="prefetch" href="/assets/base-9.html.208c7bb9.js"><link rel="prefetch" href="/assets/rollup-1.html.03002012.js"><link rel="prefetch" href="/assets/rollup-10.html.86a22541.js"><link rel="prefetch" href="/assets/rollup-11.html.e3a4642f.js"><link rel="prefetch" href="/assets/rollup-2.html.41d6ac3a.js"><link rel="prefetch" href="/assets/rollup-3.html.6ad17f68.js"><link rel="prefetch" href="/assets/rollup-4.html.7d4a4c3c.js"><link rel="prefetch" href="/assets/rollup-5.html.54596415.js"><link rel="prefetch" href="/assets/rollup-6.html.2de6134f.js"><link rel="prefetch" href="/assets/rollup-7.html.e1bb8ffd.js"><link rel="prefetch" href="/assets/rollup-8.html.1b8764c3.js"><link rel="prefetch" href="/assets/rollup-9.html.1d7bff01.js"><link rel="prefetch" href="/assets/scope-closures-appA.html.54460362.js"><link rel="prefetch" href="/assets/scope-closures-appB.html.df5a960f.js"><link rel="prefetch" href="/assets/scope-closures-appC.html.d19041c8.js"><link rel="prefetch" href="/assets/this-object-prototype-appA.html.a5e33133.js"><link rel="prefetch" href="/assets/async-performance-apA.html.1318a5e9.js"><link rel="prefetch" href="/assets/async-performance-apB.html.6a42c749.js"><link rel="prefetch" href="/assets/async-performance-ch1.html.43644825.js"><link rel="prefetch" href="/assets/async-performance-ch2.html.5569a916.js"><link rel="prefetch" href="/assets/async-performance-ch3.html.6eb4b5e0.js"><link rel="prefetch" href="/assets/async-performance-ch4.html.b1839a56.js"><link rel="prefetch" href="/assets/async-performance-ch5.html.9bd4d678.js"><link rel="prefetch" href="/assets/async-performance-ch6.html.04dbdb45.js"><link rel="prefetch" href="/assets/types-grammar-1.html.4b5e4a6d.js"><link rel="prefetch" href="/assets/types-grammar-2.html.09993b1d.js"><link rel="prefetch" href="/assets/types-grammar-4.html.e85d4a5d.js"><link rel="prefetch" href="/assets/types-grammar-5.html.a2b81328.js"><link rel="prefetch" href="/assets/types-grammar-apA.html.2924c653.js"><link rel="prefetch" href="/assets/404.html.d2dc3323.js"><link rel="prefetch" href="/assets/1.1.hello-world.html.f87c5e3d.js"><link rel="prefetch" href="/assets/1.10.if.html.77dc3aac.js"><link rel="prefetch" href="/assets/1.11.includes.html.6373ae78.js"><link rel="prefetch" href="/assets/1.12.parameters.html.9058ff22.js"><link rel="prefetch" href="/assets/1.13.push.html.ce608075.js"><link rel="prefetch" href="/assets/1.14.unshift.html.a931245a.js"><link rel="prefetch" href="/assets/1.2.Pick.html.dff96be2.js"><link rel="prefetch" href="/assets/1.3.Awaited.html.81dda58f.js"><link rel="prefetch" href="/assets/1.4.Readonly.html.36238f2d.js"><link rel="prefetch" href="/assets/1.5.Tuple-to-object.html.0b0099ac.js"><link rel="prefetch" href="/assets/1.6.First-of-array.html.00beb244.js"><link rel="prefetch" href="/assets/1.7.Length-of-Tuple.html.f88876ce.js"><link rel="prefetch" href="/assets/1.8.concat.html.8589b1fe.js"><link rel="prefetch" href="/assets/1.9.exclude.html.bc7e747b.js"><link rel="prefetch" href="/assets/2.1.Get-Return-Type.html.cac3876c.js"><link rel="prefetch" href="/assets/2.2.omit.html.f3a4349f.js"><link rel="prefetch" href="/assets/2.3.Readonly2.html.1737beae.js"><link rel="prefetch" href="/assets/2.4.Deep-Readonly.html.0b245458.js"><link rel="prefetch" href="/assets/2.5.turn-to-union.html.0c299433.js"><link rel="prefetch" href="/assets/3.1.Simple-Vue.html.55f2fe53.js"><link rel="prefetch" href="/assets/donate.html.5cb41655.js"><link rel="prefetch" href="/assets/Routine1_pattern-matching-for-extraction.html.6c98f4ad.js"><link rel="prefetch" href="/assets/basic-1.html.6a860dd6.js"><link rel="prefetch" href="/assets/basic-2.html.a6d0227e.js"><link rel="prefetch" href="/assets/basic-3.html.4aa3975b.js"><link rel="prefetch" href="/assets/http-2.html.6c62ded8.js"><link rel="prefetch" href="/assets/http-3.html.ca8b3092.js"><link rel="prefetch" href="/assets/http-interview.html.0e6a6925.js"><link rel="prefetch" href="/assets/http-optimize.html.b4e1bb6a.js"><link rel="prefetch" href="/assets/http-rpc.html.fd6c7486.js"><link rel="prefetch" href="/assets/http-websocket.html.2432d335.js"><link rel="prefetch" href="/assets/https-ecdhe.html.e93a5f88.js"><link rel="prefetch" href="/assets/https-optimize.html.dc41471a.js"><link rel="prefetch" href="/assets/https-rsa.html.daa108b5.js"><link rel="prefetch" href="/assets/ip-base.html.086353f5.js"><link rel="prefetch" href="/assets/ip-ping.html.68033e75.js"><link rel="prefetch" href="/assets/ip-ping_io.html.ebe3c32c.js"><link rel="prefetch" href="/assets/tcp-challenge-ack.html.68ead87a.js"><link rel="prefetch" href="/assets/tcp-dump.html.2de8cf1a.js"><link rel="prefetch" href="/assets/tcp-feature.html.c5a127db.js"><link rel="prefetch" href="/assets/tcp-interview.html.831f8b91.js"><link rel="prefetch" href="/assets/tcp-isn-deff.html.4c6f47e5.js"><link rel="prefetch" href="/assets/tcp-optimize.html.19aa5ce4.js"><link rel="prefetch" href="/assets/tcp-out-of-order-fin.html.facde3d7.js"><link rel="prefetch" href="/assets/tcp-queue.html.451a24bd.js"><link rel="prefetch" href="/assets/tcp-stream.html.222e0df4.js"><link rel="prefetch" href="/assets/tcp-syn.html.e6bc0339.js"><link rel="prefetch" href="/assets/Advanced-1.html.6349fdad.js"><link rel="prefetch" href="/assets/Advanced-2.html.3b4a022c.js"><link rel="prefetch" href="/assets/Advanced-3.html.080f2ab9.js"><link rel="prefetch" href="/assets/Advanced-4.html.9638a4d7.js"><link rel="prefetch" href="/assets/Advanced-5.html.665e8357.js"><link rel="prefetch" href="/assets/base-1.html.7cc0b90c.js"><link rel="prefetch" href="/assets/base-10.html.69d523e6.js"><link rel="prefetch" href="/assets/base-11.html.66768537.js"><link rel="prefetch" href="/assets/base-12.html.57a64e53.js"><link rel="prefetch" href="/assets/base-13.html.bbc769c9.js"><link rel="prefetch" href="/assets/base-14.html.58215026.js"><link rel="prefetch" href="/assets/base-15.html.59b22684.js"><link rel="prefetch" href="/assets/base-16.html.3887a292.js"><link rel="prefetch" href="/assets/base-17.html.b0178761.js"><link rel="prefetch" href="/assets/base-2.html.fb30aa47.js"><link rel="prefetch" href="/assets/base-3.html.b2afde71.js"><link rel="prefetch" href="/assets/base-4.html.ef59e9ed.js"><link rel="prefetch" href="/assets/base-5.html.2ca82580.js"><link rel="prefetch" href="/assets/base-6.html.1b0ab37b.js"><link rel="prefetch" href="/assets/base-7.html.89963722.js"><link rel="prefetch" href="/assets/base-8.html.5bd91515.js"><link rel="prefetch" href="/assets/base-9.html.905d119d.js"><link rel="prefetch" href="/assets/rollup-1.html.6b56ddc8.js"><link rel="prefetch" href="/assets/rollup-10.html.b8bdb04e.js"><link rel="prefetch" href="/assets/rollup-11.html.7bac1960.js"><link rel="prefetch" href="/assets/rollup-2.html.40921e40.js"><link rel="prefetch" href="/assets/rollup-3.html.c53b9c22.js"><link rel="prefetch" href="/assets/rollup-4.html.1a3cf109.js"><link rel="prefetch" href="/assets/rollup-5.html.eea45fb7.js"><link rel="prefetch" href="/assets/rollup-6.html.24eed356.js"><link rel="prefetch" href="/assets/rollup-7.html.7e3895d9.js"><link rel="prefetch" href="/assets/rollup-8.html.a4414797.js"><link rel="prefetch" href="/assets/rollup-9.html.40576d10.js"><link rel="prefetch" href="/assets/scope-closures-appA.html.686c3731.js"><link rel="prefetch" href="/assets/scope-closures-appB.html.ae1a70af.js"><link rel="prefetch" href="/assets/scope-closures-appC.html.beda04da.js"><link rel="prefetch" href="/assets/this-object-prototype-appA.html.1d350ec3.js"><link rel="prefetch" href="/assets/async-performance-apA.html.fc474119.js"><link rel="prefetch" href="/assets/async-performance-apB.html.9c5fb979.js"><link rel="prefetch" href="/assets/async-performance-ch1.html.391cfd51.js"><link rel="prefetch" href="/assets/async-performance-ch2.html.68f1ca43.js"><link rel="prefetch" href="/assets/async-performance-ch3.html.f7b1aea8.js"><link rel="prefetch" href="/assets/async-performance-ch4.html.eab53c5c.js"><link rel="prefetch" href="/assets/async-performance-ch5.html.4625ed62.js"><link rel="prefetch" href="/assets/async-performance-ch6.html.558fb103.js"><link rel="prefetch" href="/assets/types-grammar-1.html.dda1c4aa.js"><link rel="prefetch" href="/assets/types-grammar-2.html.97b42ac4.js"><link rel="prefetch" href="/assets/types-grammar-4.html.6c8ab89f.js"><link rel="prefetch" href="/assets/types-grammar-5.html.f0fdc94e.js"><link rel="prefetch" href="/assets/types-grammar-apA.html.a9ef0801.js"><link rel="prefetch" href="/assets/404.html.99e92f7a.js">
    <link rel="stylesheet" href="/assets/style.f4d22aab.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><!--v-if--></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">第3章 原生函数 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#内部-class" class="router-link-active router-link-exact-active sidebar-item" aria-label="内部 [[Class]]"><!--[--><!--]--> 内部 [[Class]] <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#封箱包装器" class="router-link-active router-link-exact-active sidebar-item" aria-label="封箱包装器"><!--[--><!--]--> 封箱包装器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#对象包装器的坑" class="router-link-active router-link-exact-active sidebar-item" aria-label="对象包装器的坑"><!--[--><!--]--> 对象包装器的坑 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#开箱" class="router-link-active router-link-exact-active sidebar-item" aria-label="开箱"><!--[--><!--]--> 开箱 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#原生类型作为构造器" class="router-link-active router-link-exact-active sidebar-item" aria-label="原生类型作为构造器"><!--[--><!--]--> 原生类型作为构造器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#array" class="router-link-active router-link-exact-active sidebar-item" aria-label="Array(..)"><!--[--><!--]--> Array(..) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#object-、function-和-regexp" class="router-link-active router-link-exact-active sidebar-item" aria-label="Object(..)、Function(..) 和 RegExp(..)"><!--[--><!--]--> Object(..)、Function(..) 和 RegExp(..) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#date-和-error" class="router-link-active router-link-exact-active sidebar-item" aria-label="Date(..) 和 Error(..)"><!--[--><!--]--> Date(..) 和 Error(..) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#symbol" class="router-link-active router-link-exact-active sidebar-item" aria-label="Symbol(..)"><!--[--><!--]--> Symbol(..) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#原生类型原型" class="router-link-active router-link-exact-active sidebar-item" aria-label="原生类型原型"><!--[--><!--]--> 原生类型原型 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/you-dont-know-js/volume-2/types-grammar-3.html#复习" class="router-link-active router-link-exact-active sidebar-item" aria-label="复习"><!--[--><!--]--> 复习 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="第3章-原生函数" tabindex="-1"><a class="header-anchor" href="#第3章-原生函数" aria-hidden="true">#</a> 第3章：原生函数</h1><p>在第1和第2章中，我们多次提到了一些内建函数，通常称为“原生类型”，比如 <code>String</code> 和 <code>Number</code>。现在让我们来仔细检视它们。</p><p>这是最常用的原生类型的一览：</p><ul><li><code>String()</code></li><li><code>Number()</code></li><li><code>Boolean()</code></li><li><code>Array()</code></li><li><code>Object()</code></li><li><code>Function()</code></li><li><code>RegExp()</code></li><li><code>Date()</code></li><li><code>Error()</code></li><li><code>Symbol()</code> —— 在 ES6 中被加入的！</li></ul><p>如你所见，这些原生类型实际上是内建函数。</p><p>熟悉<code>Java</code>的开发者会发现，JavaScript 的 <code>String()</code> 看起来像是你曾经用来创建字符串值的 <code>String(..)</code> 构造器。所以，你很快就会观察到你可以做这样的事情：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Hello World!&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这些原生类型的每一种确实可以被用作一个原生类型的构造器。但是被构建的东西可能与你想象的不同：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot; ... 不是 &quot;String&quot;</span>
a <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object String]&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建值的构造器形式（<code>new String(&quot;abc&quot;)</code>）的结果是一个基本类型值（<code>&quot;abc&quot;</code>）的包装器对象。</p><p>重要的是，<code>typeof</code> 显示这些对象不是它们自己的特殊 <em>类型</em>，而是 <code>object</code> 类型的子类型。</p><p>这个包装器对象可以被进一步观察，像这样：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个语句的输出会根据你使用的浏览器变化，因为对于开发者的查看，开发者控制台可以自由选择它认为合适的方式来序列化对象。</p><p><strong>注意：</strong> 在写作本书时，最新版的 Chrome 打印出这样的东西：<code>String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}</code>。但是老版本的 Chrome 曾经只打印出这些：<code>String {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}</code>。当前最新版的 Firefox 打印 <code>String [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>，但它曾经以斜体字打印 <code>&quot;abc&quot;</code>，点击它可以打开对象查看器。当然，这些结果是总频繁变更的，而且你的体验也许不同。</p><p>重点是，<code>new String(&quot;abc&quot;)</code> 为 <code>&quot;abc&quot;</code> 创建了一个字符串包装器对象，而不仅是基本类型值 <code>&quot;abc&quot;</code> 本身。</p><h2 id="内部-class" tabindex="-1"><a class="header-anchor" href="#内部-class" aria-hidden="true">#</a> 内部 <code>[[Class]]</code></h2><p><code>typeof</code> 的结果为 <code>&quot;object&quot;</code> 的值（比如数组）被额外地打上了一个内部的标签属性 <code>[[Class]]</code>（请把它考虑为一个内部的分类方法，而非与传统的面向对象编码的类有关）。这个属性不能直接地被访问，但通常可以间接地通过在这个值上借用默认的 <code>Object.prototype.toString(..)</code> 方法调用来展示。举例来说：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Array]&quot;</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">regex-literal</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object RegExp]&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，对于这个例子中的数组来说，内部的 <code>[[Class]]</code> 值是 <code>&quot;Array&quot;</code>，而对于正则表达式，它是 <code>&quot;RegExp&quot;</code>。在大多数情况下，这个内部的 <code>[[Class]]</code> 值对应于关联这个值的内建的原生类型构造器（见下面的讨论），但事实却不总是这样。</p><p>基本类型呢？首先，<code>null</code> 和 <code>undefined</code>：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Null]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Undefined]&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>你会注意到，不存在 <code>Null()</code> 和 <code>Undefined()</code> 原生类型构造器，但不管怎样 <code>&quot;Null&quot;</code> 和 <code>&quot;Undefined&quot;</code> 是被暴露出来的内部 <code>[[Class]]</code> 值。</p><p>但是对于像 <code>string</code>、<code>number</code>、和 <code>boolean</code> 这样的简单基本类型，实际上会启动另一种行为，通常称为“封箱（boxing）”（见下一节“封箱包装器”）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object String]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Number]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Boolean]&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个代码段中，每一个简单基本类型都自动地被它们分别对应的对象包装器封箱，这就是为什么 <code>&quot;String&quot;</code>、<code>&quot;Number&quot;</code>、和 <code>&quot;Boolean&quot;</code> 分别被显示为内部 <code>[[Class]]</code> 值。</p><p><strong>注意：</strong> 从 ES5 发展到 ES6 的过程中，这里展示的 <code>toString()</code> 和 <code>[[Class]]</code> 的行为发生了一点儿改变，但我们会在本系列的 <em>ES6 与未来</em> 一书中讲解它们的细节。</p><h2 id="封箱包装器" tabindex="-1"><a class="header-anchor" href="#封箱包装器" aria-hidden="true">#</a> 封箱包装器</h2><p>这些对象包装器服务于一个非常重要的目的。基本类型值没有属性或方法，所以为了访问 <code>.length</code> 或 <code>.toString()</code> 你需要这个值的对象包装器。值得庆幸的是，JS 将会自动地 <em>封箱</em>（也就是包装）基本类型值来满足这样的访问。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;ABC&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，如果你想以通常的方式访问这些字符串值上的属性/方法，比如一个 <code>for</code> 循环的 <code>i &lt; a.length</code> 条件，这么做看起来很有道理：一开始就得到一个这个值的对象形式，于是 JS 引擎就不需要隐含地为你创建一个。</p><p>但事实证明这是一个坏主意。浏览器们长久以来就对 <code>.length</code> 这样的常见情况进行性能优化，这意味着如果你试着直接使用对象形式（它们没有被优化过）进行“提前优化”，那么实际上你的程序将会 <em>变慢</em>。</p><p>一般来说，基本上没有理由直接使用对象形式。让封箱在需要的地方隐含地发生会更好。换句话说，永远也不要做 <code>new String(&quot;abc&quot;)</code>、<code>new Number(42)</code> 这样的事情 —— 应当总是偏向于使用基本类型字面量 <code>&quot;abc&quot;</code> 和 <code>42</code>。</p><h3 id="对象包装器的坑" tabindex="-1"><a class="header-anchor" href="#对象包装器的坑" aria-hidden="true">#</a> 对象包装器的坑</h3><p>如果你 <em>确实</em> 选择要直接使用对象包装器，那么有几个坑你应该注意。</p><p>举个例子，考虑 <code>Boolean</code> 包装的值：</p><p>🚩：注意</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//a  --&gt; Boolean {false}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Oops&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 永远不会运行</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的问题是，虽然你为值 <code>false</code> 创建了一个对象包装器，但是对象本身是“truthy”（见第四章），所以使用对象的效果是与使用底层的值 <code>false</code> 本身相反的，这与通常的期望十分不同。</p><p>如果你想手动封箱一个基本类型值，你可以使用 <code>Object(..)</code> 函数（没有 <code>new</code> 关键字）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// &quot;string&quot;</span>
<span class="token keyword">typeof</span> b<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot;</span>
<span class="token keyword">typeof</span> c<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot;</span>

b <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object String]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object String]&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再说一遍，通常不鼓励直接使用封箱的包装器对象（比如上面的 <code>b</code> 和 <code>c</code>），但你可能会遇到一些它们有用的罕见情况。</p><h2 id="开箱" tabindex="-1"><a class="header-anchor" href="#开箱" aria-hidden="true">#</a> 开箱</h2><p>如果你有一个包装器对象，而你想要取出底层的基本类型值，你可以使用 <code>valueOf()</code> 方法：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;abc&quot;</span>
b<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
c<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当以一种查询基本类型值的方式使用对象包装器时，开箱也会隐含地发生。这个处理的过程（强制转换）将会在第四章中更详细地讲解，但简单地说：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token comment">// `b` 拥有开箱后的基本类型值&quot;abc&quot;</span>

<span class="token keyword">typeof</span> a<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot;</span>
<span class="token keyword">typeof</span> b<span class="token punctuation">;</span> <span class="token comment">// &quot;string&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="原生类型作为构造器" tabindex="-1"><a class="header-anchor" href="#原生类型作为构造器" aria-hidden="true">#</a> 原生类型作为构造器</h2><p>对于 <code>array</code>、<code>object</code>、<code>function</code> 和正则表达式值来说，使用字面形式来创建它们的值几乎总是更好的选择，而且字面形式与构造器形式所创建的值是同一种对象（也就是，没有非包装的值）。</p><p>正如我们刚刚在上面看到的其他原生类型，除非你真的知道你需要这些构造器形式，一般来说应当避免使用它们，这主要是因为它们会带来一些你可能不会想要对付的异常和陷阱。</p><h3 id="array" tabindex="-1"><a class="header-anchor" href="#array" aria-hidden="true">#</a> <code>Array(..)</code></h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
b<span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> <code>Array(..)</code> 构造器不要求在它前面使用 <code>new</code> 关键字。如果你省略它，它也会像你已经使用了一样动作。所以 <code>Array(1,2,3)</code> 和 <code>new Array(1,2,3)</code> 的结果是一样的。</p><p><code>Array</code> 构造器有一种特殊形式，如果它仅仅被传入一个 <code>number</code> 参数，与将这个值作为数组的 <em>内容</em> 不同，它会被认为是用来“预定数组大小”（嗯，某种意义上）用的长度。</p><p>这是个可怕的主意。首先，你会意外地用错这种形式，因为它很容易忘记。</p><p>但更重要的是，其实没有预定数组大小这样的东西。你所创建的是一个空数组，并将这个数组的 <code>length</code> 属性设置为那个指定的数字值。</p><p>一个数组在它的值槽上没有明确的值，但是有一个 <code>length</code> 属性意味着这些值槽是存在的，在 JS 中这是一个诡异的数据结构，它带有一些非常奇怪且令人困惑的行为。可以创建这样的值的能力，完全源自于老旧的、已经废弃的、仅具有历史意义的功能（比如<code> arguments</code> 这样的“类数组对象”）。</p><p><strong>注意：</strong> 带有至少一个“空值槽”的数组经常被称为“稀散数组”。</p><p>这是另外一个例子，展示浏览器的开发者控制台在如何表示这样的对象上有所不同，它产生了更多的困惑。</p><p>举例来说：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Chrome 中 <code>a</code> 的序列化表达是（在本书写作时）：<code>[ undefined x 3 ]</code>。<strong>这真的很不幸。</strong> 它暗示着在这个数组的值槽中有三个 <code>undefined</code> 值，而事实上这样的值槽是不存在的（所谓的“空值槽（empty slots）” —— 也是一个烂名字！）。</p><p>要观察这种不同，试试这段代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span>
b<span class="token punctuation">;</span>
c<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> 正如你在这个例子中看到的 <code>c</code>，数组中的空值槽可以在数组的创建之后发生。将数组的 <code>length</code> 改变为超过它实际定义的槽值的数目，你就隐含地引入了空值槽。事实上，你甚至可以在上面的代码段中调用 <code>delete b[1]</code>，而这么做将会在 <code>b</code> 的中间引入一个空值槽。</p><p>对于 <code>b</code>（在当前的 Chrome 中），你会发现它的序列化表现为 <code>[ undefined, undefined, undefined ]</code>，与之相对的是 <code>a</code> 和 <code>c</code> 的 <code>[ undefined x 3 ]</code>。糊涂了吧？是的，大家都糊涂了。</p><p>更糟糕的是，在写作本书时，Firefox 对 <code>a</code> 和 <code>c</code> 报告 <code>[ , , , ]</code>。你发现为什么这使人犯糊涂了吗？仔细看。三个逗号表示有四个值槽，不是我们期望的三个值槽。</p><p><strong>什么！？</strong> Firefox 在它们的序列化表达的末尾放了一个额外的 <code>,</code>，因为在 ES5 中，列表（数组值，属性列表等等）末尾的逗号是允许的（被砍掉并忽略）。所以如果你在你的程序或控制台中敲入 <code>[ , , , ]</code> 值，你实际上得到的是一个底层为 <code>[ , , ]</code> 的值（也就是，一个带有三个空值槽的数组）。这种选择，虽然在阅读开发者控制台时使人困惑，但是因为它使拷贝粘贴的时候准确，所以被留了下来。</p><p>如果你现在在摇头或翻白眼儿，你并不孤单！（耸肩）</p><p>不幸的是，事情越来越糟。比在控制台的输出产生的困惑更糟的是，上面代码段中的 <code>a</code> 和 <code>b</code> 实际上在有些情况下相同，<strong>但在另一些情况下不同</strong>：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>a<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;--&quot;</span>
b<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;--&quot;</span>

a<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ undefined x 3 ]</span>
b<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [ 0, 1, 2 ]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>呃。</strong></p><p><code>a.map(..)</code> 调用会 <em>失败</em> 是因为值槽根本就不实际存在，所以 <code>map(..)</code> 没有东西可以迭代。<code>join(..)</code> 的工作方式不同，基本上我们可以认为它是像这样被实现的：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fakeJoin</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> connector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      str <span class="token operator">+=</span> connector<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      str <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fakeJoin</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;--&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，<code>join(..)</code> 好用仅仅是因为它 <em>认为</em> 值槽存在，并循环至 <code>length</code> 值。不管 <code>map(..)</code> 内部是在做什么，它（显然）没有做出这样的假设，所以源自于奇怪的“空值槽”数组的结果出人意料，而且好像是失败了。</p><p>那么，如果你想要 <em>确实</em> 创建一个实际的 <code>undefined</code> 值的数组（不只是“空值槽”），你如何才能做到呢（除了手动以外）？</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// [ undefined, undefined, undefined ]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>糊涂了吧？是的。这里是它大概的工作方式。</p><p><code>apply(..)</code> 是一个对所有函数可用的工具方法，它以一种特殊方式调用这个使用它的函数。</p><p>第一个参数是一个 <code>this</code> 对象绑定（在本系列的 <em>this 与对象原型</em> 中有详细讲解），在这里我们不关心它，所以我们将它设置为 <code>null</code>。第二个参数应该是一个数组（或 <em>像</em> 数组的东西 —— 也就是“类数组对象”）。这个“数组”的内容作为这个函数的参数“扩散”开来。</p><p>所以，<code>Array.apply(..)</code> 在调用 <code>Array(..)</code> 函数，并将一个值（<code>{ length: 3 }</code> 对象值）作为它的参数值扩散开。</p><p>在 <code>apply(..)</code> 内部，我们可以预见这里有另一个 <code>for</code> 循环（有些像上面的 <code>join(..)</code>），它从 <code>0</code> 开始上升但不包含至 <code>length</code>（这个例子中是 <code>3</code>）。</p><p>对于每一个索引，它从对象中取得相应的键。所以如果这个数组对象参数在 <code>apply(..)</code> 内部被命名为 <code>arr</code>，那么这种属性访问实质上是<code>arr[0]</code>、<code>arr[1]</code> 和 <code>arr[2]</code>。当然，没有一个属性是在 <code>{ length: 3 }</code> 对象值上存在的，所以这三个属性访问都将返回值 <code>undefined</code>。</p><p>换句话说，调用 <code>Array(..)</code> 的结局基本上是这样：<code>Array(undefined,undefined,undefined)</code>，这就是我们如何得到一个填满 <code>undefined</code> 值的数组的，而非仅仅是一些（疯狂的）空值槽。</p><p>虽然对于创建一个填满 <code>undefined</code> 值的数组来说，<code>Array.apply( null, { length: 3 } )</code> 是一个奇怪而且繁冗的方法，但是它要比使用砸自己的脚似的 <code>Array(3)</code> 空值槽要可靠和好得 <strong>太多了</strong>。</p><p>底线：你 <strong>在任何情况下，永远不</strong>，也不应该有意地创建并使用诡异的空值槽数组。就别这么干。它们是怪胎。</p><h3 id="object-、function-和-regexp" tabindex="-1"><a class="header-anchor" href="#object-、function-和-regexp" aria-hidden="true">#</a> <code>Object(..)</code>、<code>Function(..)</code> 和 <code>RegExp(..)</code></h3><p><code>Object(..)</code>/<code>Function(..)</code>/<code>RegExp(..)</code> 构造器一般来说也是可选的（因此除非是特别的目的，应当避免使用）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span>
c<span class="token punctuation">;</span> <span class="token comment">// { foo: &quot;bar&quot; }</span>

<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
d<span class="token punctuation">;</span> <span class="token comment">// { foo: &quot;bar&quot; }</span>

<span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;return a * 2;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot;^a*b+&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;g&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^a*b+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>几乎没有理由使用 <code>new Object()</code> 构造器形式，尤其因为它强迫你一个一个地添加属性，而不是像对象的字面形式那样一次添加许多。</p><p><code>Function</code> 构造器仅在最最罕见的情况下有用，也就是你需要动态地定义一个函数的参数和/或它的函数体。<strong>不要将 <code>Function(..)</code> 仅仅作为另一种形式的 <code>eval(..)</code></strong>。你几乎永远不会需要用这种方式动态定义一个函数。</p><p>用字面量形式（<code>/^a*b+/g</code>）定义正则表达式是被大力采用的，不仅因为语法简单，而且还有性能的原因 —— JS 引擎会在代码执行前预编译并缓存它们。和我们迄今看到的其他构造器形式不同，<code>RegExp(..)</code> 有一些合理的用途：用来动态定义一个正则表达式的范例。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;Kyle&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> namePattern <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot;\\b(?:&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;)+\\b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ig&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> matches <span class="token operator">=</span> someText<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>namePattern<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的场景在 JS 程序中一次又一次地合法出现，所以你有需要使用 <code>new RegExp(&quot;pattern&quot;,&quot;flags&quot;)</code> 形式。</p><h3 id="date-和-error" tabindex="-1"><a class="header-anchor" href="#date-和-error" aria-hidden="true">#</a> <code>Date(..)</code> 和 <code>Error(..)</code></h3><p><code>Date(..)</code> 和 <code>Error(..)</code> 原生类型构造器要比其他种类的原生类型有用得多，因为它们没有字面量形式。</p><p>要创建一个日期对象值，你必须使用 <code>new Date()</code>。<code>Date(..)</code> 构造器接收可选参数值来指定要使用的日期/时间，但是如果省略的话，就会使用当前的日期/时间。</p><p>目前你构建一个日期对象的最常见的理由是要得到当前的时间戳（一个有符号整数，从 1970 年 1 月 1 日开始算起的毫秒数）。你可以在一个日期对象实例上调用 <code>getTime（)</code> 得到它。</p><p>但是在 ES5 中，一个更简单的方法是调用定义为 <code>Date.now()</code> 的静态帮助函数。而且在前 ES5 中填补它很容易：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Date<span class="token punctuation">.</span>now<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Date<span class="token punctuation">.</span><span class="token function-variable function">now</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> 如果你不带 <code>new</code> 调用 <code>Date()</code>，你将会得到一个那个时刻的日期/时间的字符串表达。在语言规范中没有规定这个表达的确切形式，虽然各个浏览器趋向于赞同使用这样的东西：<code>&quot;Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)&quot;</code>。</p><p><code>Error(..)</code> 构造器（很像上面的 <code>Array()</code>）在有 <code>new</code> 与没有 <code>new</code> 时的行为是相同的。</p><p>你想要创建 error 对象的主要原因是，它会将当前的执行栈上下文捕捉进对象中（在大多数 JS 引擎中，在创建后使用只读的 <code>.stack</code> 属性表示）。这个栈上下文包含函数调用栈和 error 对象被创建时的行号，这使调试这个错误更简单。</p><p>典型地，你将与 <code>throw</code> 操作符一起使用这样的 error 对象：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;x wasn&#39;t provided&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ..</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Error 对象实例一般拥有至少一个 <code>message</code> 属性，有时还有其他属性（你应当将它们作为只读的），比如 <code>type</code>。然而，与其检视上面提到的 <code>stack</code> 属性，最好是在 error 对象上调用 <code>toString()</code>（明确地调用，或者是通过强制转换隐含地调用 —— 见第四章）来得到一个格式友好的错误消息。</p><p><strong>提示：</strong> 技术上讲，除了一般的 <code>Error(..)</code> 原生类型以外，还有几种特定错误的原生类型：<code>EvalError(..)</code>、<code>RangeError(..)</code>、<code>ReferenceError(..)</code>、<code>SyntaxError(..)</code>、<code>TypeError(..)</code> 和 <code>URIError(..)</code>。但是手动使用这些特定错误原生类型十分少见。如果你的程序确实遭受了一个真实的异常，它们是会自动地被使用的（比如引用一个未声明的变量而得到一个 <code>ReferenceError</code> 错误）。</p><h3 id="symbol" tabindex="-1"><a class="header-anchor" href="#symbol" aria-hidden="true">#</a> <code>Symbol(..)</code></h3><p>在 ES6 中，新增了一个基本值类型，称为“Symbol”。Symbol 是一种特殊的“独一无二”（不是严格保证的!）的值，可以作为对象上的属性使用而几乎不必担心任何冲突。它们主要是为特殊的 ES6 结构的内建行为设计的，但你也可以定义你自己的 symbol。</p><p>Symbol 可以用做属性名，但是你不能从你的程序中看到或访问一个 symbol 的实际值，从开发者控制台也不行。例如，如果你在开发者控制台中对一个 Symbol 求值，将会显示 <code>Symbol(Symbol.create)</code> 之类的东西。</p><p>在 ES6 中有几种预定义的 Symbol，做为 <code>Symbol</code> 函数对象的静态属性访问，比如 <code>Symbol.create</code>，<code>Symbol.iterator</code> 等等。要使用它们，可以这样做：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>obj<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*..*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要定义你自己的 Symbol，使用 <code>Symbol(..)</code> 原生类型。<code>Symbol(..)</code> 原生类型“构造器”很独特，因为它不允许你将 <code>new</code> 与它一起使用，这么做会抛出一个错误。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> mysym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;my own symbol&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mysym<span class="token punctuation">;</span> <span class="token comment">// Symbol(my own symbol)</span>
mysym<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Symbol(my own symbol)&quot;</span>
<span class="token keyword">typeof</span> mysym<span class="token punctuation">;</span> <span class="token comment">// &quot;symbol&quot;</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span>mysym<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;foobar&quot;</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [ Symbol(my own symbol) ]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然 Symbol 实际上不是私有的（在对象上使用 <code>Object.getOwnPropertySymbols(..)</code> 反射，揭示了 Symbol 其实是相当公开的），但是它们的主要用途可能是私有属性，或者类似的特殊属性。对于大多数开发者，他们也许会在属性名上加入 <code>_</code> 下划线前缀，这在经常在惯例上表示：“这是一个私有的/特殊的/内部的属性，别碰！”</p><p><strong>注意：</strong> <code>Symbol</code> <em>不是</em> <code>object</code>，它们是简单的基本标量。</p><h3 id="原生类型原型" tabindex="-1"><a class="header-anchor" href="#原生类型原型" aria-hidden="true">#</a> 原生类型原型</h3><p>每一个内建的原生构造器都拥有它自己的 <code>.prototype</code> 对象 —— <code>Array.prototype</code>，<code>String.prototype</code> 等等。</p><p>对于它们特定的对象子类型，这些对象含有独特的行为。</p><p>例如，所有的字符串对象，和 <code>string</code> 基本值的扩展（通过封箱），都可以访问在 <code>String.prototype</code> 对象上做为方法定义的默认行为。</p><p><strong>注意：</strong> 做为文档惯例，<code>String.prototype.XYZ</code> 会被缩写为 <code>String#XYZ</code>，对于其它所有 <code>.prototype</code> 的属性都是如此。</p><ul><li><code>String#indexOf(..)</code>：在一个字符串中找出一个子串的位置</li><li><code>String#charAt(..)</code>：访问一个字符串中某个位置的字符</li><li><code>String#substr(..)</code>、<code>String#substring(..)</code> 和 <code>String#slice(..)</code>：将字符串的一部分抽取为一个新字符串</li><li><code>String#toUpperCase()</code> 和 <code>String#toLowerCase()</code>：创建一个转换为大写或小写的新字符串</li><li><code>String#trim()</code>：创建一个截去开头或结尾空格的新字符串。</li></ul><p>这些方法中没有一个是在 <em>原地</em> 修改字符串的。修改（比如大小写变换或去空格）会根据当前的值来创建一个新的值。</p><p>有赖于原型委托（见本系列的 <em>this 与对象原型</em>），任何字符串值都可以访问这些方法：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot; abc &quot;</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot; ABC &quot;</span>
a<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;abc&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他构造器的原型包含适用于它们类型的行为，比如 <code>Number#toFixed(..)</code>（将一个数字转换为一个固定小数位的字符串）和 <code>Array#concat(..)</code>（混合数组）。所有这些函数都可以访问 <code>apply(..)</code>、<code>call(..)</code> 和 <code>bind(..)</code>，因为 <code>Function.prototype</code> 定义了它们。</p><p>但是，一些原生类型的原型不 <em>仅仅</em> 是单纯的对象：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">typeof</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// &quot;function&quot;</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">prototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 它是一个空函数！</span>

<span class="token class-name">RegExp</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;/(?:)/&quot; —— 空的正则表达式</span>
<span class="token string">&quot;abc&quot;</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token class-name">RegExp</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;&quot;]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个特别差劲儿的主意是，你甚至可以修改这些原生类型的原型（不仅仅是你可能熟悉的添加属性）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>

<span class="token comment">// 别这么留着它，要不就等着怪事发生吧！</span>
<span class="token comment">// 将`Array.prototype`重置为空</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，<code>Function.prototype</code> 是一个函数，<code>RegExp.prototype</code> 是一个正则表达式，而 <code>Array.prototype</code> 是一个数组。有趣吧？酷吧？</p><h4 id="原型作为默认值" tabindex="-1"><a class="header-anchor" href="#原型作为默认值" aria-hidden="true">#</a> 原型作为默认值</h4><p><code>Function.prototype</code> 是一个空函数，<code>RegExp.prototype</code> 是一个“空”正则表达式（也就是不匹配任何东西），而 <code>Array.prototype</code> 是一个空数组，这使它们成了可以赋值给变量的，很好的“默认”值 —— 如果这些类型的变量还没有值。</p><p>例如：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isThisCool</span><span class="token punctuation">(</span><span class="token parameter">vals<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> rx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vals <span class="token operator">=</span> vals <span class="token operator">||</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  fn <span class="token operator">=</span> fn <span class="token operator">||</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  rx <span class="token operator">=</span> rx <span class="token operator">||</span> <span class="token class-name">RegExp</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>

  <span class="token keyword">return</span> rx<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>vals<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">isThisCool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token function">isThisCool</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">D</span><span class="token regex-delimiter">/</span></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> 在 ES6 中，我们不再需要使用 <code>vals = vals || ..</code> 这样的默认值语法技巧了（见第四章），因为在函数声明中可以通过原生语法为参数设定默认值（见第五章）。</p><p>这个方式的一个微小的副作用是，<code>.prototype</code> 已经被创建了，而且是内建的，因此它仅被创建 <em>一次</em>。相比之下，使用 <code>[]</code>、<code>function(){}</code> 和 <code>/(?:)/</code> 这些值本身作为默认值，将会（很可能，要看引擎如何实现）在每次调用 <code>isThisCool(..)</code> 时重新创建这些值（而且稍可能要回收它们）。这可能会消耗内存/CPU。</p><p>另外，要非常小心不要对 <strong>后续要被修改的值</strong> 使用 <code>Array.prototype</code> 做为默认值。在这个例子中，<code>vals</code> 是只读的，但如果你要在原地对 <code>vals</code> 进行修改，那你实际上修改的是 <code>Array.prototype</code> 本身，这将把你引到刚才提到的坑里！</p><p><strong>注意：</strong> 虽然我们指出了这些原生类型的原型和一些用处，但是依赖它们的时候要小心，更要小心以任何形式修改它们。更多的讨论见附录 A“原生原型”。</p><h2 id="复习" tabindex="-1"><a class="header-anchor" href="#复习" aria-hidden="true">#</a> 复习</h2><p>JavaScript 为基本类型提供了对象包装器，被称为原生类型（<code>String</code>、<code>Number</code>、<code>Boolean</code> 等等）。这些对象包装器使这些值可以访问每种对象子类型的恰当行为（<code>String#trim()</code> 和 <code>Array#concat(..)</code>）。</p><p>如果你有一个像 <code>&quot;abc&quot;</code> 这样的简单基本类型标量，而且你想要访问它的 <code>length</code> 属性或某些 <code>String.prototype</code> 方法，JS 会自动地“封箱”这个值（用它所对应种类的对象包装器把它包起来），以满足这样的属性/方法访问。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1453300745@qq.com">wangtao</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.c62ce33e.js" defer></script>
  </body>
</html>
